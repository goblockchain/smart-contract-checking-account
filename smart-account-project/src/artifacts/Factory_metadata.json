{
	"compiler": {
		"version": "0.8.20+commit.a1b79de6"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "account",
						"type": "address"
					}
				],
				"name": "AddressInsufficientBalance",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "ArrayLengthMismatch",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "uint48",
						"name": "deadline",
						"type": "uint48"
					}
				],
				"name": "ERC2771ForwarderExpiredRequest",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "signer",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "from",
						"type": "address"
					}
				],
				"name": "ERC2771ForwarderInvalidSigner",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "requestedValue",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "msgValue",
						"type": "uint256"
					}
				],
				"name": "ERC2771ForwarderMismatchedValue",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "target",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "forwarder",
						"type": "address"
					}
				],
				"name": "ERC2771UntrustfulTarget",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "FailedInnerCall",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "ForbiddenSender",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "account",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "currentNonce",
						"type": "uint256"
					}
				],
				"name": "InvalidAccountNonce",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "InvalidCalldata",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "InvalidShortString",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					}
				],
				"name": "InvalidUser",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "Locked",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "string",
						"name": "str",
						"type": "string"
					}
				],
				"name": "StringTooLong",
				"type": "error"
			},
			{
				"anonymous": false,
				"inputs": [],
				"name": "EIP712DomainChanged",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "signer",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "nonce",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "bool",
						"name": "success",
						"type": "bool"
					}
				],
				"name": "ExecutedForwardRequest",
				"type": "event"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_admin",
						"type": "address"
					}
				],
				"name": "addAdmin",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newAdmins",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"name": "admin",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"name": "admins",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_users",
						"type": "address[]"
					}
				],
				"name": "batchPause",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_users",
						"type": "address[]"
					},
					{
						"internalType": "address[]",
						"name": "_newSmartAccounts",
						"type": "address[]"
					}
				],
				"name": "batchSetSmartAccounts",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256[]",
						"name": "_users",
						"type": "uint256[]"
					},
					{
						"internalType": "address[]",
						"name": "_newSmartAccounts",
						"type": "address[]"
					}
				],
				"name": "batchSetSmartAccounts",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_users",
						"type": "address[]"
					}
				],
				"name": "batchUnpause",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_users",
						"type": "address[]"
					},
					{
						"internalType": "int256[]",
						"name": "_liabilities",
						"type": "int256[]"
					}
				],
				"name": "batchUpdate",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "string",
						"name": "_user",
						"type": "string"
					},
					{
						"internalType": "address[]",
						"name": "admins",
						"type": "address[]"
					},
					{
						"internalType": "uint256",
						"name": "minAllocation",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "acceptERC20Tokens",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "permittedERC20Tokens",
						"type": "address[]"
					},
					{
						"internalType": "bool",
						"name": "acceptERC721Tokens",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "permittedERC721Tokens",
						"type": "address[]"
					},
					{
						"internalType": "bool",
						"name": "acceptERC1155Tokens",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "permittedERC1155Tokens",
						"type": "address[]"
					},
					{
						"internalType": "uint256",
						"name": "percentageFromAllocation",
						"type": "uint256"
					},
					{
						"internalType": "address[]",
						"name": "paymentTokens",
						"type": "address[]"
					},
					{
						"internalType": "bool",
						"name": "includesNonce",
						"type": "bool"
					},
					{
						"internalType": "uint256",
						"name": "nonce",
						"type": "uint256"
					},
					{
						"internalType": "uint8",
						"name": "v",
						"type": "uint8"
					},
					{
						"internalType": "bytes32",
						"name": "r",
						"type": "bytes32"
					},
					{
						"internalType": "bytes32",
						"name": "s",
						"type": "bytes32"
					},
					{
						"internalType": "bool",
						"name": "useDefault",
						"type": "bool"
					}
				],
				"name": "create",
				"outputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "smartAccount",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "string",
						"name": "user",
						"type": "string"
					},
					{
						"internalType": "uint256",
						"name": "minAllocation",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "acceptERC20Tokens",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "permittedERC20Tokens",
						"type": "address[]"
					},
					{
						"internalType": "bool",
						"name": "acceptERC721Tokens",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "permittedERC721Tokens",
						"type": "address[]"
					},
					{
						"internalType": "bool",
						"name": "acceptERC1155Tokens",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "permittedERC1155Tokens",
						"type": "address[]"
					},
					{
						"internalType": "uint256",
						"name": "percentageFromAllocation",
						"type": "uint256"
					},
					{
						"internalType": "address[]",
						"name": "paymentTokens",
						"type": "address[]"
					},
					{
						"internalType": "bool",
						"name": "includesNonce",
						"type": "bool"
					},
					{
						"internalType": "uint256",
						"name": "nonce",
						"type": "uint256"
					},
					{
						"internalType": "uint8",
						"name": "v",
						"type": "uint8"
					},
					{
						"internalType": "bytes32",
						"name": "r",
						"type": "bytes32"
					},
					{
						"internalType": "bytes32",
						"name": "s",
						"type": "bytes32"
					},
					{
						"internalType": "bool",
						"name": "useDefault",
						"type": "bool"
					}
				],
				"name": "create",
				"outputs": [
					{
						"internalType": "address",
						"name": "_user",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "smartAccount",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_users",
						"type": "address[]"
					}
				],
				"name": "credits",
				"outputs": [
					{
						"internalType": "int256[]",
						"name": "credits",
						"type": "int256[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "userId",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "refund",
						"type": "bool"
					}
				],
				"name": "deactivate",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "eip712Domain",
				"outputs": [
					{
						"internalType": "bytes1",
						"name": "fields",
						"type": "bytes1"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "version",
						"type": "string"
					},
					{
						"internalType": "uint256",
						"name": "chainId",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "verifyingContract",
						"type": "address"
					},
					{
						"internalType": "bytes32",
						"name": "salt",
						"type": "bytes32"
					},
					{
						"internalType": "uint256[]",
						"name": "extensions",
						"type": "uint256[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "from",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "to",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "value",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "gas",
								"type": "uint256"
							},
							{
								"internalType": "uint48",
								"name": "deadline",
								"type": "uint48"
							},
							{
								"internalType": "bytes",
								"name": "data",
								"type": "bytes"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct ERC2771Forwarder.ForwardRequestData",
						"name": "request",
						"type": "tuple"
					}
				],
				"name": "execute",
				"outputs": [],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "from",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "to",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "value",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "gas",
								"type": "uint256"
							},
							{
								"internalType": "uint48",
								"name": "deadline",
								"type": "uint48"
							},
							{
								"internalType": "bytes",
								"name": "data",
								"type": "bytes"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct ERC2771Forwarder.ForwardRequestData[]",
						"name": "requests",
						"type": "tuple[]"
					},
					{
						"internalType": "address payable",
						"name": "refundReceiver",
						"type": "address"
					}
				],
				"name": "executeBatch",
				"outputs": [],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "forwarder",
						"type": "address"
					}
				],
				"name": "isTrustedForwarder",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "owner",
						"type": "address"
					}
				],
				"name": "nonces",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "number",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256[]",
						"name": "usersIds",
						"type": "uint256[]"
					},
					{
						"internalType": "int256",
						"name": "amounts",
						"type": "int256"
					}
				],
				"name": "punish",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_admin",
						"type": "address"
					}
				],
				"name": "removeAdmin",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newAdmins",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_users",
						"type": "address[]"
					}
				],
				"name": "scores",
				"outputs": [
					{
						"internalType": "int256[]",
						"name": "scores",
						"type": "int256[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "userId",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "minAllocation",
						"type": "uint256"
					}
				],
				"name": "setMinAllocation",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "newMinAllocation",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "paymentTokens",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "tokenType",
						"type": "uint256"
					}
				],
				"name": "setPaymentTokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newPaymentTokens",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "percentageFromAllocation",
						"type": "uint256"
					}
				],
				"name": "setPercentageFromAllocation",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "newPercentageFromAllocation",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setPermittedERC1155Tokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setPermittedERC20Tokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newPermittedERC20Tokens",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setPermittedERC721Tokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newPermittedERC721Tokens",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "userId",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "newSmartAccount",
						"type": "address"
					}
				],
				"name": "setSmartAccount",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_token",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_id",
						"type": "uint256"
					}
				],
				"name": "skim",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"name": "smartAccount",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"name": "tokenToStandard",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "trustedForwarder",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"name": "users",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "from",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "to",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "value",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "gas",
								"type": "uint256"
							},
							{
								"internalType": "uint48",
								"name": "deadline",
								"type": "uint48"
							},
							{
								"internalType": "bytes",
								"name": "data",
								"type": "bytes"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct ERC2771Forwarder.ForwardRequestData",
						"name": "request",
						"type": "tuple"
					}
				],
				"name": "verify",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			}
		],
		"devdoc": {
			"author": "Caio SÃ¡",
			"errors": {
				"AddressInsufficientBalance(address)": [
					{
						"details": "The ETH balance of the account is not enough to perform the operation."
					}
				],
				"ERC2771ForwarderExpiredRequest(uint48)": [
					{
						"details": "The request `deadline` has expired."
					}
				],
				"ERC2771ForwarderInvalidSigner(address,address)": [
					{
						"details": "The request `from` doesn't match with the recovered `signer`."
					}
				],
				"ERC2771ForwarderMismatchedValue(uint256,uint256)": [
					{
						"details": "The `requestedValue` doesn't match with the available `msgValue`."
					}
				],
				"ERC2771UntrustfulTarget(address,address)": [
					{
						"details": "The request target doesn't trust the `forwarder`."
					}
				],
				"FailedInnerCall()": [
					{
						"details": "A call to an address target failed. The target may have reverted."
					}
				],
				"InvalidAccountNonce(address,uint256)": [
					{
						"details": "The nonce used for an `account` is not the expected current nonce."
					}
				]
			},
			"events": {
				"EIP712DomainChanged()": {
					"details": "MAY be emitted to signal that the domain could have changed."
				},
				"ExecutedForwardRequest(address,uint256,bool)": {
					"details": "Emitted when a `ForwardRequest` is executed. NOTE: An unsuccessful forward request could be due to an invalid signature, an expired deadline, or simply a revert in the requested call. The contract guarantees that the relayer is not able to force the requested call to run out of gas."
				}
			},
			"kind": "dev",
			"methods": {
				"batchSetSmartAccounts(address[],address[])": {
					"params": {
						"_newSmartAccounts": "new address of the contract with the new feature.",
						"_users": "id of user"
					}
				},
				"batchUpdate(address[],int256[])": {
					"details": "Those who have debt will be the ones that have not paid their bills. They should be punish()ed according to the decided punition.Those who have credit are probably those who've probably paid more than they should, in order to gain compound credit.Those with a 0 are the ones who are neither in debt or in credit. They've paid their bills and are supposed to continue receiving credit for the following month.",
					"params": {
						"_liabilities": "this is the actual debt (<0) or credit(>0) the user has gained in at any time.",
						"_users": "these are the target SA of each of the users whose liability is being updated."
					}
				},
				"create(string,address[],uint256,bool,address[],bool,address[],bool,address[],uint256,address[],bool,uint256,uint8,bytes32,bytes32,bool)": {
					"details": "derive user's address from user's signature (v,r,s)."
				},
				"create(string,uint256,bool,address[],bool,address[],bool,address[],uint256,address[],bool,uint256,uint8,bytes32,bytes32,bool)": {
					"params": {
						"acceptERC1155Tokens": "flag to allow/disallow erc1155s allocations",
						"acceptERC20Tokens": "flag to allow/disallow erc20s allocations",
						"acceptERC721Tokens": "flag to allow/disallow erc721s allocations",
						"includesNonce": "wether token includes nonce.",
						"minAllocation": "min allowed allocation by user",
						"nonce": "nonce if includesNonce is true.",
						"paymentTokens": "tokens allowed to be received as a payment for debt.",
						"percentageFromAllocation": "percentage of allowcation given to user as credit.",
						"permittedERC1155Tokens": "permitted erc1155 tokens",
						"permittedERC20Tokens": "permitted erc20 tokens",
						"permittedERC721Tokens": "permitted erc721 tokens",
						"r": "sig param.",
						"s": "sig param.",
						"useDefault": "the smartAccount should be customized or it should use the default values registered in the Factory. Set to true by default in back-end.",
						"user": "user's name that is on his card. If it's allowed in Brazil to have any nickname on a credit card, possibly make it be user's nickname.",
						"v": "sig param."
					}
				},
				"deactivate(uint256,bool)": {
					"params": {
						"userId": "ID of user to inactivate."
					}
				},
				"eip712Domain()": {
					"details": "See {IERC-5267}."
				},
				"execute((address,address,uint256,uint256,uint48,bytes,bytes))": {
					"details": "Executes a `request` on behalf of `signature`'s signer using the ERC-2771 protocol. The gas provided to the requested call may not be exactly the amount requested, but the call will not run out of gas. Will revert if the request is invalid or the call reverts, in this case the nonce is not consumed. Requirements: - The request value should be equal to the provided `msg.value`. - The request should be valid according to {verify}."
				},
				"executeBatch((address,address,uint256,uint256,uint48,bytes,bytes)[],address)": {
					"details": "Batch version of {execute} with optional refunding and atomic execution. In case a batch contains at least one invalid request (see {verify}), the request will be skipped and the `refundReceiver` parameter will receive back the unused requested value at the end of the execution. This is done to prevent reverting the entire batch when a request is invalid or has already been submitted. If the `refundReceiver` is the `address(0)`, this function will revert when at least one of the requests was not valid instead of skipping it. This could be useful if a batch is required to get executed atomically (at least at the top-level). For example, refunding (and thus atomicity) can be opt-out if the relayer is using a service that avoids including reverted transactions. Requirements: - The sum of the requests' values should be equal to the provided `msg.value`. - All of the requests should be valid (see {verify}) when `refundReceiver` is the zero address. NOTE: Setting a zero `refundReceiver` guarantees an all-or-nothing requests execution only for the first-level forwarded calls. In case a forwarded request calls to a contract with another subcall, the second-level call may revert without the top-level call reverting."
				},
				"isTrustedForwarder(address)": {
					"details": "Indicates whether any particular address is the trusted forwarder."
				},
				"nonces(address)": {
					"details": "Returns the next unused nonce for an address."
				},
				"punish(uint256[],int256)": {
					"params": {
						"amounts": "amounts in which each user is to be punished.",
						"usersIds": "users to be punished."
					}
				},
				"removeAdmin(address)": {
					"details": "it works even if there's still one admin."
				},
				"scores(address[])": {
					"params": {
						"users": "user for which score will be checked."
					},
					"returns": {
						"scores": "users scores to be retrieved."
					}
				},
				"setMinAllocation(uint256,uint256)": {
					"params": {
						"minAllocation": "min quantity of tokens the user will have to allocate in the Smart Account.",
						"userId": "the user for which the minAllocation will change. If 0, change in factory, and ,therefore, for all future users."
					}
				},
				"setPaymentTokens(address,uint256)": {
					"params": {
						"paymentTokens": "token for payment",
						"tokenType": "whether it's a erc20 (0), erc721(1) or erc1155(2)."
					}
				},
				"skim(address,address,uint256)": {
					"params": {
						"_id": "id of token if it's an NFT.",
						"_to": "to whom it should be given to, possibly being the user who sent it by accident.",
						"_token": "token to be withdrawn."
					}
				},
				"trustedForwarder()": {
					"details": "Returns the address of the trusted forwarder."
				},
				"verify((address,address,uint256,uint256,uint48,bytes,bytes))": {
					"details": "Returns `true` if a request is valid for a provided `signature` at the current block timestamp. A transaction is considered valid when the target trusts this forwarder, the request hasn't expired (deadline is not met), and the signer matches the `from` parameter of the signed request. NOTE: A request may return false here but it won't cause {executeBatch} to revert if a refund receiver is provided."
				}
			},
			"stateVariables": {
				"tokenToStandard": {
					"params": {
						"_token": "address of token."
					}
				}
			},
			"title": "Factory",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"admin(address)": {
					"notice": "checks whether `account` is authorized to modify user's smart account."
				},
				"batchSetSmartAccounts(address[],address[])": {
					"notice": "to be used when new feature has come to the protocol. Funds need to be retrieved from old smart accounts to new ones through the skim() function inside this function."
				},
				"batchUpdate(address[],int256[])": {
					"notice": "Called to update users's SA liabilities. This function will probably be called once a month to update user's states. This function can be used or a direct call to an user's SA can be made through its `update` function, at any given time. 1) The user will have his credit updated only when he allocates - which will be available only through the front-end. If a user does not deposit anything more than his initial deposit, only the company will be able to update his credit based on his off-chain card usage & repayment."
				},
				"create(string,uint256,bool,address[],bool,address[],bool,address[],uint256,address[],bool,uint256,uint8,bytes32,bytes32,bool)": {
					"notice": "callable only by goBlockchain. Have an id for each user. Sort permitted tokens to place them correctly in a tokenIndex mapping. address(0) must be the token of ID 0, so that we can avoid users passing in address(0) tokens. Like Uniswap, have a salt determined by specific user's address that can't be predicted, for example, using the custom name. Back/front-end needs to check whether there's a smart account for a user already. If not, make the user deposit the tokens in the factory, then user's funds are transferred to his smart account - to avoid company wasting gas if user requests a new factory to be created and (s)he doesn't deposit any tokens in the SA. Also, this is more efficient for the company because they don't have to pay two different txs. In its creation - or make another function specifically for this, the smartAccount needs to approve the the factory for a token to get its funds at anytime."
				},
				"deactivate(uint256,bool)": {
					"notice": "Marks user as inactive and pauses Smart Account user's contract. Refunds should be given to users, if any. Callable by goBlockchain only."
				},
				"punish(uint256[],int256)": {
					"notice": "We still need to decide how to penalize the user on-chain. This is fundamental to how the protocol will work. If the user does not fear being penalized, (s)he won't have any fear of incurring debt sequentially. One of the ways to do it on chain is to dimish user's score. The punish cannot take anymore tokens from the user by making them approve uint(-1) and us pulling them whenever the user's punished. The user may easily transfer his tokens to another account, making himself unpunished. So, we should actually use the tokens he has deposited in order to punish him. Question: 1) The contract will need to have been supplied with a good amount of ETH. If not, payments before the due date || parcial payments won't be supported because imagine the scenario where users come at different days to pay their bills but there's enough gas for the company to pay user's bills."
				},
				"scores(address[])": {
					"notice": "it retrieves users' scores for accountability."
				},
				"setMinAllocation(uint256,uint256)": {
					"notice": "it sets the minAllocation for a certain user. If userId == 0, then it sets the minAllocation for all future users."
				},
				"setPaymentTokens(address,uint256)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes."
				},
				"setPermittedERC1155Tokens(address)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes. TokenType is also handled here: whether it's a erc20 (0), erc721(1) or erc1155(2)."
				},
				"setPermittedERC20Tokens(address)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes. TokenType is also handled here: whether it's a erc20 (0), erc721(1) or erc1155(2)."
				},
				"setPermittedERC721Tokens(address)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes. TokenType is also handled here: whether it's a erc20 (0), erc721(1) or erc1155(2)."
				},
				"skim(address,address,uint256)": {
					"notice": "withdraws any tokens directly transferred to this contract or to any SA contract by accident. If token to be withdrawn is the zero address, withdraw ether from contract."
				},
				"smartAccount(address)": {
					"notice": "helper mapping to retrieve a SA associated to an user."
				},
				"tokenToStandard(address)": {
					"notice": "gets a token from its address and check whether it's a erc20 (0), erc721(1) or erc1155(2)."
				},
				"users(address)": {
					"notice": "helper mapping to make sure user is part of the protocol. Define if this will either mean user has deposited already or user has received their credit card."
				}
			},
			"notice": "This is the contract responsible for managing and creating the SmartAccount contracts.",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"src/Factory.sol": "Factory"
		},
		"evmVersion": "shanghai",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": true,
			"runs": 200
		},
		"remappings": [
			":ds-test/=lib/forge-std/lib/ds-test/src/",
			":forge-std/=lib/forge-std/src/"
		],
		"viaIR": true
	},
	"sources": {
		"lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol": {
			"keccak256": "0x92aa1df62dc3d33f1656d63bede0923e0df0b706ad4137c8b10b0a8fe549fd92",
			"license": "MIT",
			"urls": [
				"bzz-raw://c5c0f29195ad64cbe556da8e257dac8f05f78c53f90323c0d2accf8e6922d33a",
				"dweb:/ipfs/QmQ61TED8uaCZwcbh8KkgRSsCav7x7HbcGHwHts3U4DmUP"
			]
		},
		"lib/openzeppelin-contracts/contracts/metatx/ERC2771Context.sol": {
			"keccak256": "0x3cf982133d4c9c92e6cd0f3dd8399791b7858c09dfe6ab5c6073e7f24475aa78",
			"license": "MIT",
			"urls": [
				"bzz-raw://eb2e41b4db6b6020a4406b0bc1c3e959554321650a392c30ee506e464abe6f27",
				"dweb:/ipfs/QmerRLZmojENXg816AjVBwmjWpUFUHPTGFboirRCotZr3L"
			]
		},
		"lib/openzeppelin-contracts/contracts/metatx/ERC2771Forwarder.sol": {
			"keccak256": "0xd7efed2df83914cb6354b0ecddbabbf1cd0b7263bbec797a31e2251d3bf1c5e2",
			"license": "MIT",
			"urls": [
				"bzz-raw://7474f3651acee5c62a1c360f11c8718e5680a9f050fbec1ca82796402b528314",
				"dweb:/ipfs/QmW3vpvTcARQnbbQgJ8B7zrZeqRJ7xifKD5egivq2EBbBY"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
			"keccak256": "0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70",
			"license": "MIT",
			"urls": [
				"bzz-raw://0ea104e577e63faea3b69c415637e99e755dcbf64c5833d7140c35a714d6d90c",
				"dweb:/ipfs/Qmau6x4Ns9XdyynRCNNp3RhLqijJjFm7z5fyZazfYFGYdq"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
			"keccak256": "0x6008dabfe393240d73d7dd7688033f72740d570aa422254d29a7dce8568f3aff",
			"license": "MIT",
			"urls": [
				"bzz-raw://f5196ec75139918c6c7bb4251b36395e668f1fa6d206beba7e7520e74913940d",
				"dweb:/ipfs/QmSyqjksXxmm2mCG6qRd1yuwLykypkSVBbnBnGqJRcuJMi"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
			"keccak256": "0x37bb49513c49c87c4642a891b13b63571bc87013dde806617aa1efb54605f386",
			"license": "MIT",
			"urls": [
				"bzz-raw://b3036b3a83b7c48f96641f2a9002b9f2dcb6a5958dd670894ada21ae8229b3d0",
				"dweb:/ipfs/QmUNfSBdoVtjhETaUJCYcaC7pTMgbhht926tJ2uXJbiVd3"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/Address.sol": {
			"keccak256": "0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721",
			"license": "MIT",
			"urls": [
				"bzz-raw://b7bd24e224f67f65bfadf85dc2929fa965456bb2415478bd0125471b5ce35245",
				"dweb:/ipfs/QmRaydGr8BTHs1kvaZfsNU69pKzUAGFrvABn1KiRSbE51y"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/Context.sol": {
			"keccak256": "0x75a4ee64c68dbd5f38bddd06e664a64c8271b4caa554fb6f0607dfd672bb4bf3",
			"license": "MIT",
			"urls": [
				"bzz-raw://0c4e6cb30d3601e2f7af5af09e265508147cb275a8dcd99d6f7363645cc56867",
				"dweb:/ipfs/QmNgFkoXNWoUbAyw71rr1sKQ95Rj2GfvYiWg79xEYDn2NY"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/Nonces.sol": {
			"keccak256": "0x0082767004fca261c332e9ad100868327a863a88ef724e844857128845ab350f",
			"license": "MIT",
			"urls": [
				"bzz-raw://132dce9686a54e025eb5ba5d2e48208f847a1ec3e60a3e527766d7bf53fb7f9e",
				"dweb:/ipfs/QmXn1a2nUZMpu2z6S88UoTfMVtY2YNh86iGrzJDYmMkKeZ"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol": {
			"keccak256": "0x18a7171df639a934592915a520ecb97c5bbc9675a1105607aac8a94e72bf62c6",
			"license": "MIT",
			"urls": [
				"bzz-raw://7478e1f13da69a2867ccd883001d836b75620362e743f196376d63ed0c422a1c",
				"dweb:/ipfs/QmWywcQ9TNfwtoqAxbn25d8C5VrV12PrPS9UjtGe6pL2BA"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
			"keccak256": "0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418",
			"license": "MIT",
			"urls": [
				"bzz-raw://1ae50c8b562427df610cc4540c9bf104acca7ef8e2dcae567ae7e52272281e9c",
				"dweb:/ipfs/QmTHiadFCSJUPpRjNegc5SahmeU8bAoY8i9Aq6tVscbcKR"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
			"keccak256": "0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792",
			"license": "MIT",
			"urls": [
				"bzz-raw://6e52e0a7765c943ef14e5bcf11e46e6139fa044be564881378349236bf2e3453",
				"dweb:/ipfs/QmZEeeXoFPW47amyP35gfzomF9DixqqTEPwzBakv6cZw6i"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol": {
			"keccak256": "0xeed0a08b0b091f528356cbc7245891a4c748682d4f6a18055e8e6ca77d12a6cf",
			"license": "MIT",
			"urls": [
				"bzz-raw://ba80ba06c8e6be852847e4c5f4492cef801feb6558ae09ed705ff2e04ea8b13c",
				"dweb:/ipfs/QmXRJDv3xHLVQCVXg1ZvR35QS9sij5y9NDWYzMfUfAdTHF"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol": {
			"keccak256": "0x999f705a027ed6dc2d4e0df2cc4a509852c6bfd11de1c8161bf88832d0503fd0",
			"license": "MIT",
			"urls": [
				"bzz-raw://0798def67258d9a3cc20b2b4da7ebf351a5cefe0abfdd665d2d81f8e32f89b21",
				"dweb:/ipfs/QmPEvJosnPfzHNjKvCv2D3891mA2Ww8eUwkqrxBjuYdHCt"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol": {
			"keccak256": "0xba333517a3add42cd35fe877656fc3dfcc9de53baa4f3aabbd6d12a92e4ea435",
			"license": "MIT",
			"urls": [
				"bzz-raw://2ceacff44c0fdc81e48e0e0b1db87a2076d3c1fb497341de077bf1da9f6b406c",
				"dweb:/ipfs/QmRUo1muMRAewxrKQ7TkXUtknyRoR57AyEkoPpiuZQ8FzX"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
			"keccak256": "0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d",
			"license": "MIT",
			"urls": [
				"bzz-raw://4ece9f0b9c8daca08c76b6b5405a6446b6f73b3a15fab7ff56e296cbd4a2c875",
				"dweb:/ipfs/QmQyRpyPRL5SQuAgj6SHmbir3foX65FJjbVTTQrA2EFg6L"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
			"keccak256": "0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72",
			"license": "MIT",
			"urls": [
				"bzz-raw://7d533a1c97cd43a57cd9c465f7ee8dd0e39ae93a8fb8ff8e5303a356b081cdcc",
				"dweb:/ipfs/QmVBEei6aTnvYNZp2CHYVNKyZS4q1KkjANfY39WVXZXVoT"
			]
		},
		"src/Factory.sol": {
			"keccak256": "0x037fa7ffdc717f413746588a1e1fe19b43b64acafb535a94221aa5c1f1fcdb75",
			"license": "UNLICENSED",
			"urls": [
				"bzz-raw://ad9dea11fe89f7160701b8f13d5bfdcf4a1f71c6a5af33100e1e2357a02cb063",
				"dweb:/ipfs/QmXM1TN4HeKYNTMsGNkX5xRsSNtuSEonCuDbuVBppfmuj5"
			]
		},
		"src/SmartAccount.sol": {
			"keccak256": "0xc3ab23dd250faac70291addb8f04d01e9d140774cd0e9259058acf703c03fcb8",
			"license": "UNLICENSED",
			"urls": [
				"bzz-raw://6b3ab41eaef3787be27e022c2f67a015b29261238ca04196b4973bb11b0648ce",
				"dweb:/ipfs/QmU2UvrJJPAfkvmR7ZwzZ78Xc6ua5Z29gd2nn6hvJGouF6"
			]
		},
		"src/helpers/Errors.sol": {
			"keccak256": "0xc49273c15b04c7dc2520e3d92b903cc00bda3fd50d05d87561fbbb0d14593082",
			"license": "UNLICENSED",
			"urls": [
				"bzz-raw://44abade86621226648896de8428e37c5cddb9bbd2996e1c99cdcab34fc43fa5f",
				"dweb:/ipfs/QmRZHSj4vHsYo9EKYZzo6fkvbu7uLwkK2GfhtEf1neytGX"
			]
		},
		"src/interfaces/IFactory.sol": {
			"keccak256": "0x488e98992ff26281d1ac090d1a9843a1f31403d21336f724979654abd54c9154",
			"license": "SEE LICENSE IN LICENSE",
			"urls": [
				"bzz-raw://251b65e68a28290b78d332c7552d6034f78c464c43197d10bb85fce0713a62e9",
				"dweb:/ipfs/QmeFvUjggynX2XkgvMYxSQTHWZgrmnKN4gvh4kfkj2T1Hw"
			]
		},
		"src/interfaces/ISmartAccount.sol": {
			"keccak256": "0xc408a48f070f42219ed13e239ef8da9ba89062f8691d58215cb8034f0af3a71e",
			"license": "SEE LICENSE IN LICENSE",
			"urls": [
				"bzz-raw://c40a09d201c8d31245ced06b2d1cd94a8741d39fc23710da75ac97e1a1ba8573",
				"dweb:/ipfs/QmUQ9Lr3ix5yi5vxrSFm43mrXH9KDDi2x2HBEdjtYkaaiG"
			]
		}
	},
	"version": 1
}
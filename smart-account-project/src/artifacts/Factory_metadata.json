{
	"compiler": {
		"version": "0.8.21+commit.d9974bed"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_firstUser",
						"type": "address"
					},
					{
						"internalType": "string",
						"name": "_firstUserName",
						"type": "string"
					}
				],
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"inputs": [],
				"name": "ArrayLengthMismatch",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "ForbiddenSender",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "InvalidCalldata",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "token",
						"type": "address"
					}
				],
				"name": "InvalidToken",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					}
				],
				"name": "InvalidUser",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "Locked",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "nonUser",
						"type": "address"
					}
				],
				"name": "NotAUser",
				"type": "error"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"internalType": "address",
						"name": "user",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "address",
						"name": "smartAccount",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "int256",
						"name": "change",
						"type": "int256"
					},
					{
						"indexed": false,
						"internalType": "int256",
						"name": "credit",
						"type": "int256"
					}
				],
				"name": "CreditUpdated",
				"type": "event"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_admin",
						"type": "address"
					}
				],
				"name": "addAdmin",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newAdmins",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "admin",
						"type": "address"
					}
				],
				"name": "admin",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"name": "admins",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "users",
						"type": "address[]"
					},
					{
						"internalType": "address[]",
						"name": "_newSmartAccounts",
						"type": "address[]"
					}
				],
				"name": "batchSetSmartAccounts",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "users",
						"type": "address[]"
					},
					{
						"internalType": "int256[]",
						"name": "_liabilities",
						"type": "int256[]"
					}
				],
				"name": "batchUpdate",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_user",
						"type": "address"
					},
					{
						"internalType": "string",
						"name": "_username",
						"type": "string"
					}
				],
				"name": "create",
				"outputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "smartAccount",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "users",
						"type": "address[]"
					}
				],
				"name": "credits",
				"outputs": [
					{
						"internalType": "int256[]",
						"name": "",
						"type": "int256[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "userId",
						"type": "uint256"
					},
					{
						"internalType": "bool",
						"name": "refund",
						"type": "bool"
					}
				],
				"name": "deactivate",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_token",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_id",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "_amount",
						"type": "uint256"
					}
				],
				"name": "move",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "operator",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "from",
						"type": "address"
					},
					{
						"internalType": "uint256[]",
						"name": "ids",
						"type": "uint256[]"
					},
					{
						"internalType": "uint256[]",
						"name": "values",
						"type": "uint256[]"
					},
					{
						"internalType": "bytes",
						"name": "data",
						"type": "bytes"
					}
				],
				"name": "onERC1155BatchReceived",
				"outputs": [
					{
						"internalType": "bytes4",
						"name": "",
						"type": "bytes4"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "operator",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "from",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "id",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "value",
						"type": "uint256"
					},
					{
						"internalType": "bytes",
						"name": "data",
						"type": "bytes"
					}
				],
				"name": "onERC1155Received",
				"outputs": [
					{
						"internalType": "bytes4",
						"name": "",
						"type": "bytes4"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "operator",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "from",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "tokenId",
						"type": "uint256"
					},
					{
						"internalType": "bytes",
						"name": "data",
						"type": "bytes"
					}
				],
				"name": "onERC721Received",
				"outputs": [
					{
						"internalType": "bytes4",
						"name": "",
						"type": "bytes4"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256[]",
						"name": "usersIds",
						"type": "uint256[]"
					},
					{
						"internalType": "int256",
						"name": "amounts",
						"type": "int256"
					}
				],
				"name": "punish",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "string",
						"name": "userName",
						"type": "string"
					}
				],
				"name": "registerSelf",
				"outputs": [
					{
						"internalType": "address",
						"name": "smartUserAccount",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "_tokens",
						"type": "address[]"
					},
					{
						"internalType": "uint256[]",
						"name": "_types",
						"type": "uint256[]"
					}
				],
				"name": "registerTokens",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_admin",
						"type": "address"
					}
				],
				"name": "removeAdmin",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newAdmins",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address[]",
						"name": "users",
						"type": "address[]"
					}
				],
				"name": "scores",
				"outputs": [
					{
						"internalType": "int256[]",
						"name": "scores",
						"type": "int256[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "userId",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "minAllocation",
						"type": "uint256"
					}
				],
				"name": "setMinAllocation",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "newMinAllocation",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "paymentTokens",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "tokenType",
						"type": "uint256"
					}
				],
				"name": "setPaymentTokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newPaymentTokens",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "percentageFromAllocation",
						"type": "uint256"
					}
				],
				"name": "setPercentageFromAllocation",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "newPercentageFromAllocation",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setPermittedERC1155Tokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setPermittedERC20Tokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newPermittedERC20Tokens",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenAddress",
						"type": "address"
					}
				],
				"name": "setPermittedERC721Tokens",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "newPermittedERC721Tokens",
						"type": "address[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "newSmartAccount",
						"type": "address"
					}
				],
				"name": "setSmartAccount",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					}
				],
				"name": "smartAccount",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes4",
						"name": "interfaceId",
						"type": "bytes4"
					}
				],
				"name": "supportsInterface",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "token",
						"type": "address"
					}
				],
				"name": "tokenToStandard",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "user",
						"type": "address"
					}
				],
				"name": "user",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"stateMutability": "payable",
				"type": "receive"
			}
		],
		"devdoc": {
			"author": "Caio Sá",
			"kind": "dev",
			"methods": {
				"batchSetSmartAccounts(address[],address[])": {
					"params": {
						"_newSmartAccounts": "new address of the contract with the new feature.",
						"users": "id of user"
					}
				},
				"create(address,string)": {
					"details": "derive user's address from user's signature (v,r,s)."
				},
				"deactivate(uint256,bool)": {
					"params": {
						"userId": "ID of user to inactivate."
					}
				},
				"move(address,address,uint256,uint256)": {
					"params": {
						"_amount": "amount of token, if applicable.",
						"_id": "id of token if it's an NFT.",
						"_to": "to whom it should be given to, possibly being the user who sent it by accident.",
						"_token": "token to be withdrawn."
					}
				},
				"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
					"details": "Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. NOTE: To accept the transfer(s), this must return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81, or its own function selector).",
					"params": {
						"data": "Additional data with no specified format",
						"from": "The address which previously owned the token",
						"ids": "An array containing ids of each token being transferred (order and length must match values array)",
						"operator": "The address which initiated the batch transfer (i.e. msg.sender)",
						"values": "An array containing amounts of each token being transferred (order and length must match ids array)"
					},
					"returns": {
						"_0": "`bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed"
					}
				},
				"punish(uint256[],int256)": {
					"params": {
						"amounts": "amounts in which each user is to be punished.",
						"usersIds": "users to be punished."
					}
				},
				"registerTokens(address[],uint256[])": {
					"details": "_types must be 1 for ERC20, 2 for ERC721 and 3 for ERC1155",
					"params": {
						"_tokens": "tokens addressess to be registered.",
						"_types": "token types that will represent the token.abi"
					}
				},
				"removeAdmin(address)": {
					"details": "it works even if there's still one admin."
				},
				"scores(address[])": {
					"params": {
						"users": "user for which score will be checked."
					},
					"returns": {
						"scores": "users scores to be retrieved."
					}
				},
				"setMinAllocation(uint256,uint256)": {
					"params": {
						"minAllocation": "min quantity of tokens the user will have to allocate in the Smart Account.",
						"userId": "the user for which the minAllocation will change. If 0, change in factory, and ,therefore, for all future users."
					}
				},
				"setPaymentTokens(address,uint256)": {
					"params": {
						"paymentTokens": "token for payment",
						"tokenType": "whether it's a erc20 (0), erc721(1) or erc1155(2)."
					}
				},
				"supportsInterface(bytes4)": {
					"details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
				}
			},
			"title": "Factory",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"batchSetSmartAccounts(address[],address[])": {
					"notice": "to be used when new feature has come to the protocol. Funds need to be retrieved from old smart accounts to new ones through the skim() function inside this function."
				},
				"deactivate(uint256,bool)": {
					"notice": "Marks user as inactive and pauses Smart Account user's contract. Refunds should be given to users, if any. Callable by goBlockchain only."
				},
				"move(address,address,uint256,uint256)": {
					"notice": "withdraws any tokens directly transferred to this contract or to any SA contract by accident. If token to be withdrawn is the zero address, withdraw ether from contract."
				},
				"onERC1155Received(address,address,uint256,uint256,bytes)": {
					"notice": "the function below as is MUST NOT be used in production. This is only a demo for a presentation"
				},
				"onERC721Received(address,address,uint256,bytes)": {
					"notice": "the function below as is MUST NOT be used in production. This is only a demo for a presentation"
				},
				"punish(uint256[],int256)": {
					"notice": "We still need to decide how to penalize the user on-chain. This is fundamental to how the protocol will work. If the user does not fear being penalized, (s)he won't have any fear of incurring debt sequentially. One of the ways to do it on chain is to dimish user's score. The punish cannot take anymore tokens from the user by making them approve uint(-1) and us pulling them whenever the user's punished. The user may easily transfer his tokens to another account, making himself unpunished. So, we should actually use the tokens he has deposited in order to punish him. Question: 1) The contract will need to have been supplied with a good amount of ETH. If not, payments before the due date || parcial payments won't be supported because imagine the scenario where users come at different days to pay their bills but there's enough gas for the company to pay user's bills."
				},
				"registerTokens(address[],uint256[])": {
					"notice": "it registers a token in case the token does not trigger a callback, like ERC20 tokens do not do."
				},
				"scores(address[])": {
					"notice": "it retrieves users' scores for accountability."
				},
				"setMinAllocation(uint256,uint256)": {
					"notice": "it sets the minAllocation for a certain user. If userId == 0, then it sets the minAllocation for all future users."
				},
				"setPaymentTokens(address,uint256)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes."
				},
				"setPermittedERC1155Tokens(address)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes. TokenType is also handled here: whether it's a erc20 (0), erc721(1) or erc1155(2)."
				},
				"setPermittedERC20Tokens(address)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes. TokenType is also handled here: whether it's a erc20 (0), erc721(1) or erc1155(2)."
				},
				"setPermittedERC721Tokens(address)": {
					"notice": "callable by factory's admin. Registers a new token, making it possible for it to be used as an paymentMethod. Sorting should be handled inside this function and other tokens should be reorganized in their tokenIndexes. TokenType is also handled here: whether it's a erc20 (0), erc721(1) or erc1155(2)."
				}
			},
			"notice": "This is the contract responsible for managing and creating the SmartAccount contracts.",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"src/Factory.sol": "Factory"
		},
		"evmVersion": "shanghai",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": true,
			"runs": 200
		},
		"remappings": [
			":ds-test/=lib/forge-std/lib/ds-test/src/",
			":forge-std/=lib/forge-std/src/"
		],
		"viaIR": true
	},
	"sources": {
		"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {
			"keccak256": "0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3",
			"license": "MIT",
			"urls": [
				"bzz-raw://25addbda49a578b3318130585601344c5149a5549d749adf88e9685349a46b23",
				"dweb:/ipfs/Qme2DuD8gpsve1ZvaSMQpBwMdpU7yAtekDwr7gUp8dX4zX"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
			"keccak256": "0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70",
			"license": "MIT",
			"urls": [
				"bzz-raw://0ea104e577e63faea3b69c415637e99e755dcbf64c5833d7140c35a714d6d90c",
				"dweb:/ipfs/Qmau6x4Ns9XdyynRCNNp3RhLqijJjFm7z5fyZazfYFGYdq"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
			"keccak256": "0x6008dabfe393240d73d7dd7688033f72740d570aa422254d29a7dce8568f3aff",
			"license": "MIT",
			"urls": [
				"bzz-raw://f5196ec75139918c6c7bb4251b36395e668f1fa6d206beba7e7520e74913940d",
				"dweb:/ipfs/QmSyqjksXxmm2mCG6qRd1yuwLykypkSVBbnBnGqJRcuJMi"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
			"keccak256": "0x37bb49513c49c87c4642a891b13b63571bc87013dde806617aa1efb54605f386",
			"license": "MIT",
			"urls": [
				"bzz-raw://b3036b3a83b7c48f96641f2a9002b9f2dcb6a5958dd670894ada21ae8229b3d0",
				"dweb:/ipfs/QmUNfSBdoVtjhETaUJCYcaC7pTMgbhht926tJ2uXJbiVd3"
			]
		},
		"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
			"keccak256": "0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49",
			"license": "MIT",
			"urls": [
				"bzz-raw://d01e0b2b837ee2f628545e54d8715b49c7ef2befd08356c2e7f6c50dde8a1c22",
				"dweb:/ipfs/QmWBAn6y2D1xgftci97Z3qR9tQnkvwQpYwFwkTvDMvqU4i"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/Address.sol": {
			"keccak256": "0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721",
			"license": "MIT",
			"urls": [
				"bzz-raw://b7bd24e224f67f65bfadf85dc2929fa965456bb2415478bd0125471b5ce35245",
				"dweb:/ipfs/QmRaydGr8BTHs1kvaZfsNU69pKzUAGFrvABn1KiRSbE51y"
			]
		},
		"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
			"keccak256": "0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b",
			"license": "MIT",
			"urls": [
				"bzz-raw://87b3541437c8c443ccd36795e56a338ed12855eec17f8da624511b8d1a7e14df",
				"dweb:/ipfs/QmeJQCtZrQjtJLr6u7ZHWeH3pBnjtLWzvRrKViAi7UZqxL"
			]
		},
		"src/Factory.sol": {
			"keccak256": "0x94035b255753ed3bc751fcdc7c84d0d63baad95daa3de021973d73e245614ee9",
			"license": "UNLICENSED",
			"urls": [
				"bzz-raw://c4ff005e33f0ea2dbb7dae6217d8f31bdede776d75b8998609a4913e0dd2150c",
				"dweb:/ipfs/QmYrjRjSwxV1N6zv1iHDaFadVgRAdsxfMvY6zA61gxzLFS"
			]
		},
		"src/SmartAccount.sol": {
			"keccak256": "0x4da133515454d0d5ca70b51596ccac9b4d390daff60b6e6cfb9e4c643c707f94",
			"license": "UNLICENSED",
			"urls": [
				"bzz-raw://8b128be6da2a9c5cf60522348858e159e76463f7e707d318c8de4c3804d3b097",
				"dweb:/ipfs/Qmc1YAPrfiSry2CSu8QMFkSfsReQD3Hr6kWL7mfpRnZojY"
			]
		},
		"src/helpers/Errors.sol": {
			"keccak256": "0xc723311e7977823019e0a291a2fd611d7ec3d22c43d34d19f7e865b199135918",
			"license": "UNLICENSED",
			"urls": [
				"bzz-raw://1443942d7d2e710f93433773f43c16c720d2471eecbda2e0d6d3e80e489a6a73",
				"dweb:/ipfs/QmRC6FkmxnkaDFe46ZEwmmG3p3G3jNYD4Wp2hncE4irwJU"
			]
		},
		"src/helpers/TransferHelper.sol": {
			"keccak256": "0xa4ba8423491ce0b166dd467e88857ab5043c1dd83ce7485fb7684c940a960f63",
			"urls": [
				"bzz-raw://b2a9d38a0b0b3251b30b8443b865b6bd1f23d72005e19a99251c281d85ac05e9",
				"dweb:/ipfs/QmeZKahjwnycGgN95wFwETww4LXdiryeKFogxd2wns9y36"
			]
		},
		"src/interfaces/IFactory.sol": {
			"keccak256": "0x94554a2bb601821780bad1b26de5ce27dd17cdf7216976f4ab1f75a8f04e0953",
			"license": "SEE LICENSE IN LICENSE",
			"urls": [
				"bzz-raw://2d9ff517ab56bdf3a4824f809a45e8e87f28a327c96e22534af97279d12bee11",
				"dweb:/ipfs/QmYofDpqHUsW8YwFgfg9vtgqdqv3YrJ2rMZ77XniYW7ZJk"
			]
		},
		"src/interfaces/ISmartAccount.sol": {
			"keccak256": "0x86e9e36816cdb15703225659f57f3f38b9ae090b23c78b0a3d63ffcf4df7afb3",
			"license": "SEE LICENSE IN LICENSE",
			"urls": [
				"bzz-raw://4abe7ec943bb1a00356078892e3ffdcace4c4992d8e33b6fab0cb533e69eeb94",
				"dweb:/ipfs/QmewdeMb2B9Aq9Sj7ihEa71NbZN3a9ndP9DGAYFuKNKek4"
			]
		}
	},
	"version": 1
}